#!/bin/bash 
### This file ~/wsprdaemon/wd-bash-aliases  includes funtions and alieaes which are helpful in running and debugging WD systems

function wd-machine-name() {
    echo $(uname -m)
}

declare WD_ALIAS_BIN_DIR=~/wsprdaemon/bin
declare WD_ALIAS_WSPRD_REPORT_SPREAD_CMD_X86="${WD_ALIAS_BIN_DIR}/wsprd.spread_nodrift.x86"
declare WD_ALIAS_WSPRD_REPORT_SPREAD_CMD_X86_DIABLED="${WD_ALIAS_BIN_DIR}/wsprd.spread_nodrift.x86.disabled"
declare WD_ALIAS_WSPRD_REPORT_SPREAD_CMD_AARCH64="${WD_ALIAS_BIN_DIR}/wsprd.spread_nodrift.aarch64"
declare WD_ALIAS_WSPRD_REPORT_SPREAD_CMD_X86_DIABLED="${WD_ALIAS_BIN_DIR}/wsprd.spread_nodrift.x86.disabled"

### Returns the full path to where the wsprd.spread.. file should be
function wd-wsprd-report-spreading-file(){
    local spreading_file=""
    local machine_name=$(uname -m)
    case ${machine_name} in
        x86_64)
            spreading_file=${WD_ALIAS_WSPRD_REPORT_SPREAD_CMD_X86}
            ;;
        ##aarch64)
        ##    spreading_file=${WD_ALIAS_WSPRD_REPORT_SPREAD_CMD_AARCH64}
        ##     ;;
         *)
             echo "WSPR-2 frequency spreading is not supported on this ${machine_name} CPU server" 1>&2 
             return 1
             ;;
    esac
    if [[ -n "${spreading_file}" ]]; then
        spreading_path=$(realpath ${spreading_file})
    fi
    echo ${spreading_path}
    return 0
}

function wd-spreading-enable(){
    local spreading_file
    local rc
    spreading_file=$( wd-wsprd-report-spreading-file )
    rc=$?
    if [[ ${rc} -ne 0 || -z "${spreading_file}" ]]; then
        echo "WSPR-2 spreading reporting is not supported on this server"
        return 1
    fi
    if [[ -x ${spreading_file} ]]; then
        echo "WSPR-2 spreading reporting is already enabled"
        return 0
    fi
    local disabled_spreading_file="${spreading_file}.disabled"
    if [[ ! -x ${disabled_spreading_file} ]]; then
        echo "ERROR: missing the expected saved WSPR-2 spreading reporting file"
        return 2
    fi
    cp -p ${disabled_spreading_file} ${spreading_file}
    rc=$?
     if [[ ${rc} -ne 0 ]]; then
         echo "ERROR: failed to restore the saved spreading command ${disabled_spreading_file}"
        return 3
    fi
    echo "WSPR-2 spreading reporting is enabled on this server"
    return 0
}

function wd-spreading-disable(){
    local spreading_file
    local rc
    spreading_file=$( wd-wsprd-report-spreading-file )
    rc=$?
    if [[ ${rc} -ne 0 || -z "${spreading_file}" ]]; then
        echo "WSPR-2 spreading reporting is not supported on this server"
        return 1
    fi
    if [[ ! -x ${spreading_file} ]]; then
        echo "WSPR-2 spreading reporting is already disabled"
        return 0
    fi
    local disabled_spreading_file="${spreading_file}.disabled"
    mv ${spreading_file} ${disabled_spreading_file} 
    rc=$?
     if [[ ${rc} -ne 0 ]]; then
         echo "ERROR: failed to 'mv${spreading_file}  ${disabled_spreading_file}"
        return 2
    fi
    echo "WSPR-2 spreading reporting is now diabled on this server"
    return 0
}

function wd-spreading-status() {
    local spreading_file
    local rc
    spreading_file=$( wd-wsprd-report-spreading-file )
    rc=$?
    if [[ ${rc} -ne 0 || -z "${spreading_file}" ]]; then
        echo "WSPR-2 spreading reporting is not supported on this server"
        return 1
    fi
    if [[ -x ${spreading_file} ]]; then
        echo "WSPR-2 spreading reporting is ensabled"
    else
        echo "WSPR-2 spreading reporting is disabled"
    fi
    return 0
}

function wd-spreading() {
    if [[ ${#@} -eq 0 ]]; then
        wd-spreading-status
        echo "usage: wd-spreading [on|off]"
        return
    fi
    case $1 in
        on)
            wd-spreading-enable
            ;;
        off)
            wd-spreading-disable
            ;;
        *)
            echo "ERROR: '$1' is not a valid argument"
            ;;
    esac
    return 0
}

function wd-flush-empty-dirs() {
    for dir in * ;  do 
        if [[ -d $dir ]]; then
            file_count=$(find $dir -type f | wc -l)
            if [[ $file_count -eq 0 ]]; then 
                echo "Deleting empty directory $dir"
                rm -r $dir
            fi
        fi
    done
}

function wd-find-functions() {
   local bash_file=$1

   local functions_list=( $( awk '/^function/{print $2}' ${bash_file} | sed 's/(.*//' ) )

   echo "Found ${#functions_list[@]} functions: '${functions_list[*]}'"

   for function in ${functions_list[@]} ; do
       grep -w ${function}  ${bash_file}
       read
   done
}

export LC_TIME="C"          ### Forces user session 'date' to display 24 hour time

if [[ -d /dev/shm/wsprdaemon ]]; then
    WD_TMP_ROOT=/dev/shm/wsprdaemon
else
    WD_TMP_ROOT=/tmp/wsprdaemon
fi

### To speed debugging of the WD upload daemons, kill just the watchdog and upload daemons.  You can then 'wda' and watch the upload log as the WD uploader starts to work immediately
function wd-kill-uploader()
{
    kill $( cat ~/wsprdaemon/watchdog_daemon.pid  ~/wsprdaemon/uploads.d/wsprnet.d/spots.d/upload_to_wsprnet_daemon.pid )
}
alias wd-k=wd-kill-uploader
alias wdk=wd-kill-uploader

### Watch the upload log file
function wd-watch-wsprnet-upload-log()
{
    echo "To view the full log file execute the command: 'less ~/wsprdaemon/uploads.d/wsprnet.d/spots.d/upload_to_wsprnet_daemon.log'"
    tail -F ~/wsprdaemon/uploads.d/wsprnet.d/spots.d/upload_to_wsprnet_daemon.log
}
alias wd-un=wd-watch-wsprnet-upload-log
alias wdln=wd-watch-wsprnet-upload-log

### Gets status for the Kiwis listed in WD.conf
function wd-find-kiwis()
{
    local local_lan_list=( $(ip addr | grep -w inet | grep -v 'inet 127' | awk '{print $2}' | sed 's;\.[0-9]*/;.0/;g') )

    [[ ${verbosity} -gt 0 ]] && echo "Searching the ${#local_lan_list[@]} LANs for Kiwis:  ${local_lan_list[@]}"
    for lan in ${local_lan_list[@]} ; do
        echo "Searching LAN ${lan} for Kiwis"
        local kiwi_ip_list=( $( nmap --open -p 8073 ${lan} | awk '/Nmap scan report for/{print $5}' ) )
        if [[ ${#kiwi_ip_list[@]} -eq 0 ]]; then
            echo "Found no Kiwis"
        else
            echo "Found ${#kiwi_ip_list[@]} Kiwis: ${kiwi_ip_list[*]/%/  }"
        fi
    done
}

function wd-kiwi-status()
{
    local wsprconf_file=~/wsprdaemon/wsprdaemon.conf;
    if [[ ! -f ${wsprconf_file} ]]; then
        echo "ERROR: can't find config file ${wsprconf_file}";
        return;
    fi;
    source ${wsprconf_file};
    local kiwi_list=();
    for rx_line in "${RECEIVER_LIST[@]}";
    do
        local rx_fields=(${rx_line});
        local rx_name=${rx_fields[0]};
        local rx_ip_port=${rx_fields[1]};
        if [[ ${rx_name} =~ AUDIO* ]] || [[ ${rx_name} =~ MERG* ]] || [[ ${rx_name} =~ RTL* ]]; then
            [[ ${verbosity} -ge 1 ]] && echo "skipping rx ${rx_name}";
        else
            local rx_ip=${rx_ip_port/:*/};
            if ! ping -c 1 -W 1 ${rx_ip} > /dev/null; then
                echo "WARNING: the Kiwi '${rx_name}' defined in ${wsprconf_file} doesn't repond to pings";
            else
                kiwi_list+=(${rx_name},${rx_ip_port});
                [[ ${verbosity} -ge 1 ]] && echo "Added ${rx_name} => ${rx_ip}";
            fi;
        fi;
    done;
    [[ ${verbosity} -ge 1 ]] && echo "kiwi_list[@] => ${kiwi_list[@]}";
    [[ ${verbosity} -ge 1 ]] && echo;
    local users;
    local users_max;
    local gps_good;
    local users_total=0;
    local wsprdaemon_total=0;
    local channels_total=0;
    for kiwi_info in "${kiwi_list[@]}";
    do
        local kiwi_name=${kiwi_info%,*};
        local kiwi_ip=${kiwi_info#*,};
        local kiwi_status="$(curl -s http://${kiwi_ip}/status)";
        users=$(sed -n '/users=\(.*\)/s//\1/p' <<< ${kiwi_status});
        users_max=$(sed -n '/users_max=\(.*\)/s//\1/p' <<< ${kiwi_status});
        channels_total=$((channels_total + users_max));
        gps_good=$(sed -n '/gps_good=\(.*\)/s//\1/p' <<< ${kiwi_status});
        [[ ${verbosity} -ge 1 ]] && printf "%15s: %d channels, %d users, %2d GPS satellites tracked\n" "${kiwi_name}" "${users_max}" "${users}" "${gps_good}";
        curl -s http://${kiwi_ip}/users | sed -n 's/"i":\([0-9]*\)/\n\1/g ; s/},{//g ; p' | sed '/\[{/d; s/}]//; s/,/     /g' > /tmp/curl.log;
        while read user_line; do
            [[ ${verbosity} -ge 1 ]] && echo "Checking '${user_line:1}' on user line ${user_line}"
            if grep --color=auto -q wsprdaemon <<< "${user_line}"; then
                [[ ${verbosity} -ge 1 ]] && echo "skipping WD user";
                wsprdaemon_total=$((wsprdaemon_total + 1));
            else
                [[ ${verbosity} -ge 1 ]] && echo "Checking '${user_line:1}' on user line ${user_line}"
                if [[ -n "${user_line:1}" ]]; then
                    eval declare $(echo "${user_line:1}" | sed '/"\([^"]*\)":/s//\1=/g');
                    [[ $? -ne 0 ]] && continue
                    local listener_channel="${user_line:0:1}";
                    local listener_name="$(echo "$n" | sed 's/%20/ /g')";
                    local listener_location="$(echo "$g" | sed 's/%20//g')";
                    local listener_freq="$f";
                    local listener_mode="$m";
                    local listener_ip="$a";
                    local listener_time="$t";
                    printf "%12s:%s %20s %8s %3s %s %20s %s\n" "${kiwi_name}" "${listener_channel}" "'${listener_name}'" "${listener_freq}" "${listener_mode}" "${listener_time}" "${listener_ip}" "${listener_location}";
                    users_total=$((users_total + 1));
                fi;
            fi;
        done < /tmp/curl.log;
    done;
    printf "Found %d Kiwis configured for %d total rx channels, %d total listeners, %d wsprdaemon channels\n" "${#kiwi_list[@]}" $channels_total $users_total $wsprdaemon_total
}

### 'git commit'
function wd-gc()
{
    if [[ -z "$1" ]]; then
        echo "usage:  wd-gc \"commit message\""
        return
    fi
    git config --global user.email "rob@robinett.us"
    git config --global user.name "Rob"
    git commit -m "$1" -a
}

### 'git push'
alias wd-gp='git push'

#### Get the most recent commit
alias wd-gl='git log | head -n 12'

### Setup a WD server 'git cloned' with https, so it can checkin to github with ssh
function wd-gc-ssh() {
    git remote set-url origin git@github.com:rrobinett/wsprdaemon.git 
    git config --global user.email "rob@robinett.us"
    git config --global user.name "Rob Robinett"
}

### Reload this file
alias wd-rc='source ~/wsprdaemon/wd-bash-aliases'       ### Just reload this file
alias wdrc='wd-rc'

### Add sourcing this file to ~/.bash_aliases so that these bash aliases and functions are defined in every bash session
function wd-rci() 
{
    if [[ ! -f ~/.bash_aliases ]] || ! grep wd-bash-aliases ~/.bash_aliases > /dev/null ; then
        echo "
if [[ -f ~/wsprdaemon/wd-bash-aliases ]]; then
    source ~/wsprdaemon/wd-bash-aliases
fi
" >> ~/.bash_aliases
         echo "A reference to '~/wsprdaemon/wd-bash-aliases' has been added to ' ~/.bash_aliases'"
    else
         [[ ${verbosity-0} -gt 1 ]] && echo "wd-bash-aliases has already been installed in ~/.bash_aliases"
    fi
}
wd-rci
alias wdrci='wd-rci'

### Reload the local bash aliases and funtions defined in its ~/.bash_aliases, which will include this file after 'rci' has been executed
alias wd-rcc='source ~/.bash_aliases'
alias wd-rcc='wd-rcc'

### Common usasges of linux commands
alias l='ls -CF'
alias ll='ls -l'
alias lrt='ls -lrt'
alias la='ls -A'

alias pd=pushd
alias d=dirs

alias ag='alias | grep'

alias h=history
alias hg='history | grep'
alias j=jobs

alias cdw='cd ~/wsprdaemon/'
alias cdk='cd ~/wsprdaemon/ka9q-radio'
alias cdt='cd /dev/shm/wsprdaemon'
alias cdu='cd /dev/shm/wsprdaemon/uploads.d/'

### Start 'vi' using WD's .vimrc
function vi() 
{
    local vim_rc_file=~/.vimrc
    local wd_vim_rc_file=~/wsprdaemon/.vimrc

    if [[ ! -f ${vim_rc_file} ]] || ! grep wsprdaemon ${vim_rc_file}  > /dev/null ; then
        echo "Adding 'source ${wd_vim_rc_file}' to ${vim_rc_file}"
        echo "source ${wd_vim_rc_file}" >> ${vim_rc_file}
    fi
    vim $*
}

alias vib='vi ~/wsprdaemon/wd-bash-aliases'
alias vibb='vi ~/.bash_aliases'
alias viw='vi ~/wsprdaemon/wsprdaemon.sh'
alias vic='vi ~/wsprdaemon/wsprdaemon.conf'
alias vir='vi ~/wsprdaemon/radiod@rx888-wsprdaemon.conf'
alias virr='vi /etc/radio/radiod@rx888-wsprdaemon.conf'

alias tf='tail -F -n 40'
alias tfd='tf decoding_daemon.log'
alias tfr='tf wav_recording_daemon.log'
alias tfw='tf ~/wsprdaemon/watchdog_daemon.log'

alias g='git'
alias gc='git commit'
alias gd='git diff'
alias gs='git status'

### Get pub file for a copy/past to remote server's .ssh/authorized_keys file
alias catss='cat ~/.ssh/*pub'

### Helps cleanup WD source files
function find_unused_vars() {
    local sh_file=$1

    local var
    local vars=$(cat ${sh_file} | sed -n '/^declare /s///p' | sed 's/=.*//')
    for var in ${vars}; do
        local lines=$(grep -v '^declare' ${sh_file} | grep ${var})
        if [[ -z "${lines}" ]]; then
            echo "Found no usage of variable ${var}"
        fi
    done
}

### Prepends the date to each response from 'ping'
function pinge() 
{
   if [[ -z "$1" ]]; then
       echo "usage:  pinge DEST"
       return 1
   fi
   local dest=$1
   local pong

   ping ${dest} | while read pong; do echo "$(date): ${pong}"; done
}


function setup-ubuntu() {
    local remote_ip=$1

    if [[ -z "${remote_ip}" ]]; then
        echo "usage: ${FUNCNAME[0]} USER@IPADDRESS"
        return 0
    fi
    local url_list=( ${remote_ip/@/ } )
    if [[ ${#url_list[@]} -ne 2 ]]; then
        echo "ERROR: URL '${remote_ip}' doesn't contain a 'USER@IP'"
    fi
    scp -p ~/.ssh/authorized_keys ${remote_ip}:.ssh/
    scp -p ~/.vimrc ~/.bash_aliases ${remote_ip}:
    ### In an interactive login session:  run visudo to setup NOPASSWD:, install vim, disable VNC encrytion so RealVNC clients can login
    ssh ${remote_ip} "echo 'sudo visudo
    sudo apt update 
    sudo apt install vim -y
    sudo apt install git -y
    sudo apt install sox -y
    gsettings set org.gnome.Vino require-encryption false
    ' > setup-ubuntu.sh; chmod +x setup-ubuntu.sh"
    echo
    echo "Run './setup-ubuntu.sh' to finish this installation"
    echo
    ssh ${remote_ip} 
}

# Get status of all active kiwis
function kiwi-stats(){
    local wsprconf_file=~/wsprdaemon/wsprdaemon.conf

    if [[ ! -f ${wsprconf_file} ]] ; then
        echo "ERROR: can't find config file ${wsprconf_file}"
        return
    fi
    source ${wsprconf_file}

    ## Construct a list of configured and present Kiwis
    local kiwi_list=()
    for rx_line in "${RECEIVER_LIST[@]}"; do
        local rx_fields=(${rx_line})
        local rx_name=${rx_fields[0]}
        local rx_ip_port=${rx_fields[1]}
        if [[ ${rx_name} =~ AUDIO* ]] || [[ ${rx_name} =~ MERG* ]] || [[ ${rx_name} =~ RTL* ]] ; then
            [[ ${verbosity} -ge 1 ]] && echo "skipping rx ${rx_name}"
        else
            local rx_ip=${rx_ip_port/:*/}
            if ! ping -c 1 -W 1 ${rx_ip} > /dev/null ; then
                echo "WARNING: the Kiwi '${rx_name}' defined in ${wsprconf_file} doesn't repond to pings"
            else
                kiwi_list+=(${rx_name},${rx_ip_port})
                [[ ${verbosity} -ge 1 ]] && echo "Added ${rx_name} => ${rx_ip}"
            fi
        fi
    done
    [[ ${verbosity} -ge 1 ]] && echo "kiwi_list[@] => ${kiwi_list[@]}"
    [[ ${verbosity} -ge 1 ]] && echo

    local users
    local users_max
    local gps_good
    local users_total=0
    local wsprdaemon_total=0
    local channels_total=0
    for kiwi_info in "${kiwi_list[@]}" ; do
        local kiwi_name=${kiwi_info%,*}
        local kiwi_ip=${kiwi_info#*,}
        local kiwi_status="$(curl -s http://${kiwi_ip}/status)"
        users=$(sed -n '/users=\(.*\)/s//\1/p' <<< ${kiwi_status})
        users_max=$(sed -n '/users_max=\(.*\)/s//\1/p' <<< ${kiwi_status})
        channels_total=$((channels_total + users_max))
        gps_good=$(sed -n '/gps_good=\(.*\)/s//\1/p' <<< ${kiwi_status})
        [[ ${verbosity} -ge 1 ]] && printf "%15s: %d channels, %d users, %2d GPS satellites tracked\n" "${kiwi_name}" "${users_max}" "${users}" "${gps_good}"

        ### I was unable to parse the curl output when it was assigned to a bash variable. After some frustration I am using the hack of
        ### piping curl's output to a /tmp file and reading and parsing it from there

        curl -s http://${kiwi_ip}/users | sed -n 's/"i":\([0-9]*\)/\n\1/g ; s/},{//g ; p' | sed '/\[{/d; s/}]//; s/,/     /g' > /tmp/curl.log
        while read user_line; do
            if grep -q wsprdaemon <<< "${user_line}" ; then
                [[ ${verbosity} -ge 1 ]] && echo "skipping WD user"
                wsprdaemon_total=$((wsprdaemon_total + 1))
            else
                if [[ -n "${user_line:1}" ]]; then
                    eval declare $(echo "${user_line:1}" | sed '/"\([^"]*\)":/s//\1=/g')
                    local listener_channel="${user_line:0:1}"
                    local listener_name="$(echo "$n" | sed 's/%20/ /g')"
                    local listener_location="$(echo "$g" | sed 's/%20//g')"
                    local listener_freq="$f"
                    local listener_mode="$m"
                    local listener_ip="$a"
                    local listener_time="$t"
                    printf "%12s:%s %15s %8s %3s %s %20s %s\n" "${kiwi_name}" "${listener_channel}" "'${listener_name}'" "${listener_freq}" "${listener_mode}" "${listener_time}" "${listener_ip}" "${listener_location}"
                    users_total=$((users_total + 1))
                fi
            fi
        done < /tmp/curl.log
    done
    printf "Found %d Kiwis configured for %d total rx channels, %d total listeners, %d wsprdaemon channels\n" "${#kiwi_list[@]}" $channels_total  $users_total $wsprdaemon_total
}

### Aliases which call WD
alias wd='~/wsprdaemon/wsprdaemon.sh'
alias wdl='wd -l'
alias wdle='wd -l e'
alias wdld='wd -l d'
alias wda='wd -a'
alias wdz='wd -z'
alias wds='wd -s'
alias wdv='wd -V'
alias wdd='wd -d'       ### Increment the verbosity level of all running daemons in CWD
alias wddd='wd -D'       ### Decrement

function wd-merged() {
local merged_file_list=( $(find ${WD_TMP_ROOT}/ -name merged.log) )
    if [[ ${#merged_file_list[@]} -eq 0 ]]; then
        echo "There are no 'merged.log' files"
    else
        echo "Found ${#merged_file_list[@]} 'merged.log' files:"
        ls -lrt `find ${WD_TMP_ROOT}/ -name merged.log`
    fi
}


declare WD_WAV_ARCHIVE_ROOT_DIR=~/wsprdaemon/wav-archive.d    ### No "" so ~ is expanded
### 11/2/22 - This doesn't work anymore, but it could be modifed 
function wd-wav(){
    du -s ${WD_WAV_ARCHIVE_ROOT_DIR}/* | awk '{printf "%s: %s\n", $2, $1}' | sort
}
alias wdwav='wd-wav'

function wd-wav-clean() {
    local wav_archive_root_dir_list=( $(find ${WD_WAV_ARCHIVE_ROOT_DIR} -mindepth 1 -maxdepth 1 -type d | sort) )
    local wav_archive_root_dir
    for wav_archive_root_dir in ${wav_archive_root_dir_list[@]} ; do
        local flat_file_list=( $(find ${wav_archive_root_dir} -type f | sort) )  
        if [[ ${#flat_file_list[@]} -eq 0 ]]; then
            read -p "wav file root dir ${wav_archive_root_dir} conatins only directory files, so delete it? [Yn] => "
            if [[ "${REPLY:-y}" == "y" ]]; then
                rm -r ${wav_archive_root_dir}
            fi
        else
            printf "Found %6d files under %s\n"  ${#flat_file_list[@]}  ${wav_archive_root_dir}
        fi
    done
}

### At sites which are archiving wav files, this gets some info
alias wd-wav-archive='df -h ~ ; du -sh ~/wsprdaemon/wav-archive.d/ ; ls -lt ~/wsprdaemon/wav-archive.d/ | head  -n 3; ls -lt ~/wsprdaemon/wav-archive.d/ | tail -n 2'

function wd-wav-archive-fix(){
    source ~/wsprdaemon/wsprdaemon.conf
    if [[ -z "${GRAPE_PSWS_ID-}" ]]; then
        echo "This server is not configured with a GRAPE_PSWS_ID in the wsprdaemon.conf file, so can't fix the directcories"
        return 0
    fi
    if ! [[ ${GRAPE_PSWS_ID} =~ _ ]]; then
        echo "GRAPE_PSWS_ID='${GRAPE_PSWS_ID}' does not match the the expected format 'Snnnn_nnn'"
        return 0
    fi
    local date_dir
    for date_dir in $(find ${WD_WAV_ARCHIVE_ROOT_DIR} -mindepth 1 -maxdepth 1 -type d | sort ); do 
        #echo "date_dir = ${date_dir}"
        local reporter_dir
        for reporter_dir in $(find ${date_dir} -mindepth 1 -maxdepth 1 -type d | sort ); do
            #echo "reporter_dir = ${reporter_dir}"
            local receiver_dir
            for receiver_dir in $(find ${reporter_dir} -mindepth 1 -maxdepth 1 -type d | sort ); do
                echo  "Examining  ${receiver_dir} "
                if [[ ${receiver_dir} =~ "@" ]] &&  ! [[  ${receiver_dir##*@} =~ "_" ]]; then
                    read -p "Fix ${receiver_dir} to become ${receiver_dir}_${GRAPE_PSWS_ID#*_}? "
                    mv  ${receiver_dir} ${receiver_dir}_${GRAPE_PSWS_ID#*_}
                elif ! [[ ${receiver_dir} =~ "@" ]]; then
                   read -p  "Fix receiver directory ${receiver_dir} by renamaing it to ${receiver_dir}@${GRAPE_PSWS_ID}? => "
                   mv ${receiver_dir} ${receiver_dir}@${GRAPE_PSWS_ID}
                fi
            done
        done
    done
}
alias wdwaf=wd-wav-archive-fix

function wd-ssh-psws(){
    source ~/wsprdaemon/wsprdaemon.conf
    if [[ -z "${GRAPE_PSWS_ID-}" ]]; then
        echo "This server is not configured with a GRAPE_PSWS_ID in the wsprdaemon.conf file, so can't fix the directcories"
        return 0
    fi
    if ! [[ ${GRAPE_PSWS_ID} =~ _ ]]; then
        echo "GRAPE_PSWS_ID='${GRAPE_PSWS_ID}' does not match the the expected format 'Snnnn_nnn'"
        return 0
    fi
    ssh ${GRAPE_PSWS_ID%_*}@pswsnetwork.caps.ua.edu
}
alias wdssp=wd-ssh-psws

function wd-overloads()
{
: <<"comment_out"
    local log_file_list=( $(find /dev/shm/wsprdaemon/ -name wav_status.log | sort ) )
    #printf "Searching ${#log_file_list[@]} 'wav_status.log' files for WAV overload events\n%-40s YYMMDD_HHMM      MIN_SAMPLE MAX_SAMPLE Count_of MIN/MAX\n" "RECIEVER/BAND/log_file"

    if [[ ${#log_file_list[@]} -eq 0 ]]; then
        echo "Can't find any 'wav_status.log' files, so this must be an older version of WD"
    else
       true  #awk '$2 == -1.0 || $3 == 1.0 { printf( "%-40s %s\n", substr(FILENAME,33) ":", $0) } ' ${log_file_list[@]}
    fi
comment_out

    log_file_list=( $(find /dev/shm/wsprdaemon/ -name kiwi_ovs.log | sort ) )
    if [[ ${#log_file_list[@]} -eq 0 ]]; then
        echo "Can't find any 'kiwi_ovs.log' files"
        return
    fi

    if [[ $# -ne 0 && "$1" == "-f" ]]; then
        read -p "Press <ENTER> to flush all of the ${#log_file_list[@]} kiwi_ovs.log files => "
        rm ${log_file_list[@]}
        return
    fi

    ### Get a list of the Kiwis
    local kiwi_list=()
    local kiwi_root_path_list=()
    local file_path
    for file_path in ${log_file_list[@]} ; do
        local file_path_list=( ${file_path//\// } )         ### put each directory name in an element of an array
        local kiwi_name=${file_path_list[-3]-}              ### two directories up from the log file is the directory with the name of the kiwi
        set +x
        if [[ ! " ${kiwi_list[*]} " =~ " ${kiwi_name} " ]]; then
            kiwi_list+=("${kiwi_name}")
           local temp_path_list
           temp_path_list=(${file_path//\// })
           local kiwi_root_path=${temp_path_list[@]:0:$(( ${#temp_path_list[@]} - 2 ))}    ### chop off BAND/kiwi_ovs.log
           kiwi_root_path="/${kiwi_root_path// /\/}"
           #echo "kiwi_root_path = ${kiwi_root_path}"
           kiwi_root_path_list+=(${kiwi_root_path})
           set +x
           #read -p "Next Kiwi path => "
        fi
        set +x
    done
    printf "Found there are ${#kiwi_list[@]} Wsprdaemon Kiwis: ${kiwi_list[*]}\n\n"
    #echo "Found there are ${#kiwi_root_path_list[@]} Kiwi root paths: ${kiwi_root_path_list[*]}"

    for kiwi_root_path in ${kiwi_root_path_list[@]} ; do
        #echo "Searching under ${kiwi_root_path}"
        local kiwi_name=${kiwi_root_path##*/}
        log_file_list=( $(find ${kiwi_root_path}  -name kiwi_ovs.log | sort ) )

        local newest_log_file=$(ls -1t ${log_file_list[@]} | head -1)
        local most_ovs_line=$(sort -k 3n ${newest_log_file} | awk '$2 != $3' | tail -n 1)
        local ov_report_count=$( wc -l < ${newest_log_file})
        local ov_non_zero_count=$(awk '$3 != 0' ${newest_log_file} | wc -l)

        local most_ovs_line_list=( ${most_ovs_line} )
        if [[ ${most_ovs_line_list[2]-0} -eq 0 ]]; then
            printf "Kiwi ${kiwi_name} reports no overload events\n\n"
            continue
        fi

        printf "For Kiwi '${kiwi_name}' found in '${newest_log_file}', the newest of the ${#log_file_list[@]} 'kiwi_ovs.log' files:\n"
        printf "There are %6d total wspr cycles in the log file, of which %6d cycles report overload events\n"  ${ov_report_count}  ${ov_non_zero_count}
        printf "This line which reports the most OVs:\n${most_ovs_line}\n" 

        read -p "Press 'l + <RETURN>' to execute 'less ${newest_log_file}', then search for ${most_ovs_line_list[0]} => " user_input
        if [[ -n "${user_input}" ]]; then
            less ${newest_log_file}
        fi
        printf "\n"
    done
}
alias wd-ov='wd-overloads'
alias wdov='wd-ov'

function wd-query()
{
    if [[ $# -lt 1 ]]; then
        echo "usage:  wd-query {-r | -t} ID [HOURS_TO_SEARCH]       -r => search for ID of reporter     -t => search for ID of transmit beacon"
        return 0
    fi
    local query_target_field="rx_id"
    case $1 in
        -r) query_target_field="rx_id";shift ;;
        -t) query_target_field="tx_call";shift ;;
    esac
    if [[ $# -lt 1 ]]; then
        echo "ERROR: missing ID"
        echo "usage:  wd-query {-r | -t} ID [HOURS_TO_SEARCH]       -r => search for ID of reporter     -t => search for ID of transmit beacon"
        return 1
    fi
    local target_val=$1
    local query_hours=${2-1}
    local query_minutes=$((query_hours * 60))

    PGPASSWORD=JTWSPR2008 psql -U wdread -h wsprdaemon.org -p 5432 -d tutorial -c \
        "select time,tx_call,tx_grid,rx_id,receiver,rx_grid,freq,\"tx_dBm\",\"SNR\",drift,mode,metric as \"S width (mHz)\" from wsprdaemon_spots_s where ${query_target_field}='${target_val}' and mode >0 and time > now() - interval '${query_minutes} minutes' order by (time,rx_id,receiver) desc;"
}
alias wd-q='wd-query'
alias wdq='wd-query'

alias wd-syslog='sudo tail -F /var/log/syslog'
alias wd-syslogl='sudo less /var/log/syslog'
alias wdsl='wd-syslog'
alias wd-wd-rec='watch "ps aux | grep wd-rec | grep -v grep | sort -k 14,14n -k 15r"'
alias wdwd='wd-wd-rec'
function wd-wd-rec-flush()
{
    local wd_record_pids=( $(ps aux | grep wd-rec | grep -v grep | awk '{print $2}') )
    if [[ ${#wd_record_pids[@]} -gt 0 ]]; then
        echo "Flushing ${#wd_record_pids[@]} wd-record jobs"
        kill ${wd_record_pids[@]}
    fi
}

function wd-freqs(){
    local rec_root_dir="/dev/shm/wsprdaemon/recording.d"
    local rec_rx_root_dir_list=( $( find ${rec_root_dir}/* -type d -prune ) )
    local rec_bands_list=( $( find ${rec_root_dir} -mindepth 2 -maxdepth 2 -type d ! -name kiwi_status.d -printf "%f\n" | sort -u ) )

    local first_print="yes"
    for band in ${rec_bands_list[@]}; do
        if [[ ${first_print} == "no" ]]; then
            echo
        fi
        first_print=no
        for rx_root_dir in ${rec_rx_root_dir_list[@]} ; do
            local rx_name=${rx_root_dir##*/}
            echo -n "${rx_name}: "
            local rx_band_dir=${rx_root_dir}/${band}
            if [[ -d ${rx_band_dir} ]]; then
                printf "%s" "$( grep "^23.*AI6" ${rx_band_dir}/decoding_daemon.log | tail -n 1)"
            fi
            echo
        done | sort
    done
}

function wd-wavs() {
    local rx_band=$1

    if [[ -z "${rx_band}" ]]; then
        echo "usage: wd-wavs BAND"
        return 0
    fi

    for rx_dir in */${band} ; do
        ls -lt ${rx_dir}/${rx_band}/*.wav | head -1
    done
    return 0

    local rec_root_dir="/dev/shm/wsprdaemon/recording.d"
    local rec_rx_root_dir_list=( $( find ${rec_root_dir}/* -type d -prune ) )
    local rec_bands_list=( $( find ${rec_root_dir} -mindepth 2 -maxdepth 2 -type d ! -name kiwi_status.d -printf "%f\n" | sort -u ) )

    local first_print="yes"
    for band in ${rec_bands_list[@]}; do
        echo =n ${band}
    done
}

### Monitor and control the KA9Q-radio service

alias wd-rl='sudo journalctl -u radiod@rx888-wsprdaemon.service'     ### show the syslog entries for the radiod service.  add -f to watch new log lines appear
alias wdrl='wd-rl'

alias wd-ra='sudo systemctl start  radiod@rx888-wsprdaemon.service'  ### start the radiod service
alias wdra='wd-ra'
alias wd-rz='sudo systemctl stop   radiod@rx888-wsprdaemon.service'  ### stop it
alias wdrz='wd-rz'
alias wd-rs='sudo systemctl status radiod@rx888-wsprdaemon.service'  ### show it's status
alias wdrs='wd-rs'

alias wd-ra1='sudo systemctl start  radiod@rx888-wsprdaemon1.service'
alias wd-rz1='sudo systemctl stop   radiod@rx888-wsprdaemon1.service'
alias wd-rs1='sudo systemctl status radiod@rx888-wsprdaemon1.service'

alias wd-ra2='sudo systemctl start  radiod@rx888-wsprdaemon2.service'
alias wd-rz2='sudo systemctl stop   radiod@rx888-wsprdaemon2.service'
alias wd-rs2='sudo systemctl status radiod@rx888-wsprdaemon2.service'

alias swa='sudo systemctl start  wsprdaemon.service'
alias swz='sudo systemctl stop   wsprdaemon.service'
alias sws='sudo systemctl status wsprdaemon.service'

function wd-9qstats() {
    local root_dir="/dev/shm/wsprdaemon/posting.d/MERG_6_Q"
    local band_dir_list=( $(find ${root_dir} -maxdepth 1 -type d -not -wholename ${root_dir}) )
    local band_list=( ${band_dir_list[@]##*/} )

    echo "Band  Total  Q Missed       SNR    Kiwi Missed       SNR  SNR Diff"
    for band_dir in ${band_list[@]}  ; do
        local merged_log_file
        merged_log_file=${root_dir}/${band_dir}/merged.log
        if [[ ! -f ${merged_log_file} ]]; then
            echo "${band_dir}: No    merged.log in ${root_dir}/${band_dir}"
        else
            local spots_info_list=( $(awk '! /FREQUENCY/{++spots_count};\
                                     $10 == "*" {++q_missed_count};\
                                     $11 == "*" {++kiwi_missed_count};\
                                     ! /FREQUENCY/ && $10 != "*" && $11 != "*" { q_spots_sum += $10; kiwi_spots_sum += $11; ++sum_count} ;\
                                     END {printf "%5d %5d %4.2f%% %f %5d  %4.2f%% %f   %f\n", \
                                                 spots_count,\
                                                 q_missed_count,  (q_missed_count/spots_count)*100, q_spots_sum /sum_count,\
                                                 kiwi_missed_count, (kiwi_missed_count/spots_count)*100, kiwi_spots_sum/sum_count,\ 
                                                (kiwi_spots_sum/sum_count) - (q_spots_sum /sum_count) }'  ${merged_log_file}) )
            #echo "spots_info_list[] = '${spots_info_list[*]}'"
            local spots_count=${spots_info_list[0]}
            local q_missed_count=${spots_info_list[1]}
            local q_missed_percent=${spots_info_list[2]}
            local q_average=${spots_info_list[3]}
            local kiwi_missed_count=${spots_info_list[4]}
            local kiwi_missed_percent=${spots_info_list[5]}
            local kiwi_average=${spots_info_list[6]}
            local spots_diff_average=${spots_info_list[7]}

            printf "%4d: %5d   %4d %6s %5.1f        %4d %6s %5.1f   %4.2f\n" \
                ${band_dir} ${spots_count} ${q_missed_count} ${q_missed_percent} ${q_average} ${kiwi_missed_count} ${kiwi_missed_percent} ${kiwi_average} ${spots_diff_average}
        fi
    done
}

declare -A KA9Q_band_freq=(
    [160]="1836600"
    [80]="3568600"
    [60]="5287200"
    [40]="7038600"
    [30]="10138700"
    [20]="14095600"
    [17]="18104600"
    [15]="21094600"
    [12]="24924600"
    [10]="28124600"
     [6]="50293000"
)

function wd-9c()
{
    local band=${1-20}
    local tuning_freq=${KA9Q_band_freq[${band}]}

    control -s ${tuning_freq} hf.local
}

function wd-9m()
{
    local header_printed="no"
    local band
    for band in $( IFS=$'\n'; echo "${!KA9Q_band_freq[*]}" | sort -n ); do
        local metadump_out=$(metadump -n -c 1 -s ${KA9Q_band_freq[${band}]} hf.local)
        local rf_gain=$(echo "${metadump_out}" | awk '/rf gain/{print $(NF - 1) }')
        local if_power=$(echo "${metadump_out}" | awk '/IF pwr/{print $(NF - 1) }')
        local noise_level=$(echo "${metadump_out}" | awk '/N0 /{print $(NF - 1) }')
        local agc_enable=$(echo "${metadump_out}" | awk '/agc /{print $(NF - 0) }')
        local baseband_pwr=$(echo "${metadump_out}" | awk '/baseband pwr/{print $(NF - 1) }')
        local output_level=$(echo "${metadump_out}" | awk '/output level/{print $(NF - 1) }')
        local headroom=$(echo "${metadump_out}" | awk '/headroom/{print $(NF - 1) }')
        local agc_gain=$(echo "${metadump_out}" | awk '/) gain/{print $(NF - 1) }')

        if [[ ${header_printed} == "no" ]]; then
            printf "RF Gain = %4.1f, AGC %s, AGC gain %4.1f\n" ${rf_gain} ${agc_enable} ${agc_gain}
            printf "Band  IF_power  Noise_level  Baseband_power Output_level  Headroom\n" 
            header_printed="yes"
        fi
        ##     band    if_power noise_level    baseband_pwr   output_level  headroom
        printf "%3d      %6.1f      %6.1f          %6.1f       %6.1f    %6.1f\n" ${band} "${if_power}" "${noise_level}" "${baseband_pwr}" "${output_level}" "${headroom}"
    done
}

### tmux aliases
alias tm='tmux'
alias tml='tmux ls'
alias tm0='tmux a -t 0'
alias tm1='tmux a -t 1'
alias tm2='tmux a -t 2'
alias tm3='tmux a -t 3'
alias tm4='tmux a -t 4'
alias tm5='tmux a -t 5'
alias tm6='tmux a -t 6'
alias tm7='tmux a -t 7'
alias tm8='tmux a -t 8'
alias tm9='tmux a -t 9'

function wd-wait-for_wspr-gap(){
   printf "Starting at %(%M-%S)T and waiting for the next gap in the WSPR-2 packets\n" -1
   while printf -v minute "%(%M)T\n" -1 && printf -v sec "%(%S)T\n" -1 && [[ $(( minute % 2 )) -ne 1 || 10#${sec} -lt 55 ]]; do 
       [[ ${verbosity-0} -gt 0 ]] &&printf '%(%M-%S)T\n' -1
       sleep 1; 
   done
}
alias wd-wait='wd-wait-for_wspr-gap'

alias wd-nf="awk '{printf \"%2d: %s\n\", NF, \$0}'"

### git aliases

### Change a ~/wsprdaemon from https:..(git read only) to git@github.com (git read/write) so you can check in WD source code changes
function  wd-git-to-ssh(){
    local current_url=$(git remote get-url origin)
    if ! [[ "${current_url}" =~ https ]]; then
        echo "Nothing to do since current_url='${current_url}' doesn't contain the string 'https'"
        return 0
    fi
    local repo_name=${current_url/*github.com\//}
    local new_repo_url="git@github.com:${repo_name}"
    read -p "Change git's url from '${current_url}' to '${new_repo_url}'? => "
    git config --global user.email "rob@robinett.us"
    git config --global user.name "Rob Robinett"
    git remote set-url origin ${new_repo_url}
    if ! [[ -d ~/.ssh ]]; then
        echo "There is no local ssh public key file.  Runnning 'ssh-keygen to genreate one.  Press <CR> to accept all of its defaults:"
        ssh-keygen
    fi
    local public_key_file=$(find ~/.ssh -type f -name '*pub')
    if [[ -z "${public_key_file}" ]]; then
        echo "There is no local ssh public key file.  Runnning 'ssh-keygen to genreate one.  Press <CR> to accept all of its defaults:"
        ssh-keygen
    fi
    public_key_file=$(find ~/.ssh -type f -name '*pub')
    if [[ -z "${public_key_file}" ]]; then
        echo "There is still no local ssh public key file, this has failed"
        return 1
    fi
    echo "Copy and paste this ssh public key to the github.com account:"
    echo "$(< ${public_key_file})"
    return 0
}

alias wd-get-my-public_ip="dig TXT +short o-o.myaddr.l.google.com @ns1.google.com | sed 's/\"//g'"

alias wd-watch-wavs='watch "ls -l *.wav"'  ### watch for wd-record or kwirecorder to create wav files in cwd
alias wdww='wd-watch-wavs'
alias wdps='ps aux | grep wd-record | grep -v grep'

###  Reloads these functions and aliases into the users running bash (must be an alias)
alias wd-rc='source ~/wsprdaemon/wd-bash-aliases'
alias wdrc='wd-rc'

function wd-help()
{
    echo "Programs which print information about Wsprdaemon (WD) system:
Command       Can also be executed by   Description
wd-help       wd-h wd-                   Prints this help message
wd-start      wd-a wda                   Start or keep running WD
wd-stop       wd-z wdz                   Stop WD if it is running
wd-status     wd-s wds                   Show the status of a running WD 
wd-upload-wn  wd-un wdln                 Watch the 'upload to wsprnet' log
wd-upload-wd  wd-uw wdlw                 Watch the 'upload to wsprdaemon' log
wd-errors     wd-e wdle                  Each 10 seconds, search all the log files and print newly logged 'ERROR' lines
wd-overloads  wd-ov wdov                 Prints all overload events recorded in the wav and ADC log files 
wd-query      wd-q wdq                   Query the wsprdaemon database for spots
wd-gc                                    Execute git commit
wd-gp                                    Execute git push
wq-gl                                    Execute git log
wd-gc-ssh                                Execute git remote set-ur + git config
"
}
alias wd-='wd-help'
alias wd-h='wd-help'

if [[ ! -f ~/.tmux.conf ]]; then
    echo "set -g mouse on" > ~/.tmux.conf
fi

alias wdg='wd -g'

